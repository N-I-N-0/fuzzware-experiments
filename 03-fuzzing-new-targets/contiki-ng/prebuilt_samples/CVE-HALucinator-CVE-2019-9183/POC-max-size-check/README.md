# Analyzing the Crash
The crash occurs in the OS function `list_remove` as the data section has been corrupted by an out-of-bounds memcpy into an assembly buffer fragment.

> **Note**
> To replay the inputs in this directory, you may need to use the initial version of `fuzzware-emulator` and rebuild fuzzware. For instructions, see [here](https://github.com/fuzzware-fuzzer/fuzzware-experiments/tree/main/04-crash-analysis).

The overwrite itself was triggered by an out-of-bounds `memcpy` in the 6LoWPAN `store_fragment` function. While copying into the fragment buffer it is not ensured that enough space is available for fragment buffer.

This crash is a representative for different fragmentation-related bugs that were fixed in connection with CVE-2019-8359.

This bug was fixed in https://github.com/contiki-ng/contiki-ng/commit/0a54352d57b60439bcdad4ac189904ef5ced359a#diff-941ed096f58d8fc2577082fa6a1fac08380f011975b2721cc362fcd50ee040aa.

## Trace-based Bug Triaging without known Bug
To analyze the crash without knowing the bug a-priory, we can inspect the debug output of the emulator run:

```
./run.sh > log.txt
```

Inspecting log.txt:
```
Basic Block: addr= 0x0000000000208fbe (lr=0x208fed)
        >>> Read: addr= 0x00000000200003a8 size=4 data=0x20e1e1e1 (pc 0x00208fbe)
        >>> Write: addr= 0x20002bd8[SP:+0008] size=4 data=0x20001c5c (pc 0x00208fc0)
        >>> Write: addr= 0x20002bdc[SP:+0004] size=4 data=0x00208fed (pc 0x00208fc0)
Basic Block: addr= 0x0000000000208fc4 (lr=0x208fed)
        >>> [ 0x00208fc8 ] INVALID READ: addr= 0x0000000020e1e1e1 size=4 data=0x0000000000000000
Execution failed with error code: 6 -> Invalid memory read (UC_ERR_READ_UNMAPPED)

==== UC Reg state ====
r0: 0x200003a8
r1: 0x20001c5c
r2: 0x00000000
r3: 0x20e1e1e1
r4: 0x00000000
r5: 0x200003a8
r6: 0x20000238
r7: 0x2000022c
r8: 0x00000088
r9: 0x00000000
r10: 0x00000000
r11: 0x00000000
r12: 0x20001bea
lr: 0x00208fed
pc: 0x00208fc4
xpsr: 0x81000000
sp: 0x20002bd8
other_sp: 0x00000000
```

We see that firmware code tries to access addr `0x20e1e1e1` at pc `0x00208fc8`. Shortly before (at pc `0x00208fbe`), the value which is references was read from `0x200003a8` in the data section.

Inspecting the firmware, we see that the crashing functionality resides in `list_remove` and accesses a seemingly corrupted version of the global variable `ctimer_list`.

Following previous writes to address `0x200003a8`, we find:
```
Basic Block: addr= 0x0000000000208fc4 (lr=0x203c85)
        >>> Read: addr= 0x20001c5c[SP:+0f94] size=4 data=0x20e1e1e1 (pc 0x00208fc8)
Basic Block: addr= 0x0000000000208fcc (lr=0x203c85)
Basic Block: addr= 0x0000000000208fce (lr=0x203c85)
        >>> Write: addr= 0x00000000200003a8 size=4 data=0x20e1e1e1 (pc 0x00208fce)
```
Here in `list_remove` (pc: `0x00208fce`), `0x200003a8` was previously updated to `0x20e1e1e1`. The value `0x20e1e1e1` stems from a read from `0x20001c5c` (pc: `0x00208fc8`), which represents a the global timer variable `periodic_timer`.

Looking for writes to this global timer object at `0x20001c5c`, we find that a write to address `0x20001c5c`:

```
Basic Block: addr= 0x0000000000208b84 (lr=0x207d39)
Basic Block: addr= 0x0000000000208b88 (lr=0x207d39)
        >>> Read: addr= 0x00000000200006e7 size=4 data=0x20e1e1e1 (pc 0x00208b88)
        >>> Write: addr= 0x20001c5c[SP:+0f1c] size=4 data=0x20e1e1e1 (pc 0x00208b8c)
```

This corresponds to a `memcpy` (pc: `0x00208b8c`) which was called from function `store_fragment` (`lr=0x207d39`).

As in the `store_fragment` function the size of the copy operation is not checked against the maximum available fragment buffer size, an out-of-bounds and a crash occurs.