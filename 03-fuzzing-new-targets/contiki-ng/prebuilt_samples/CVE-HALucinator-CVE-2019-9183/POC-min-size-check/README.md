# Analyzing the Crash
The crash occurs in `memcpy` due to a large size argument which results from an integer underflow. The integer underflow occurs due to a missing minimum size check on an incoming FRAGN ieee801154 fragment.

> **Note**
> To replay the inputs in this directory, you may need to use the initial version of `fuzzware-emulator` and rebuild fuzzware. For instructions, see [here](https://github.com/fuzzware-fuzzer/fuzzware-experiments/tree/main/04-crash-analysis).

## Trace-based Bug Triaging without known Bug
To analyze the crash without knowing the bug a-priory, we can inspect the debug output of the emulator run:

```
./run.sh > log.txt
```

Inspecting log.txt:
```
Basic Block: addr= 0x0000000000208b20 (lr=0x207d39)
        >>> Read: addr= 0x00000000200fec37 size=4 data=0x00000000 (pc 0x00208b20)
        >>> Write: addr= 0x00000000200fffe8 size=4 data=0x00000000 (pc 0x00208b22)
        >>> Read: addr= 0x00000000200fec3b size=4 data=0x00000000 (pc 0x00208b24)
        >>> Write: addr= 0x00000000200fffec size=4 data=0x00000000 (pc 0x00208b26)
        >>> Read: addr= 0x00000000200fec3f size=4 data=0x00000000 (pc 0x00208b28)
        >>> Write: addr= 0x00000000200ffff0 size=4 data=0x00000000 (pc 0x00208b2a)
        >>> Read: addr= 0x00000000200fec43 size=4 data=0x00000000 (pc 0x00208b2c)
        >>> Write: addr= 0x00000000200ffff4 size=4 data=0x00000000 (pc 0x00208b2e)
        >>> Read: addr= 0x00000000200fec47 size=4 data=0x00000000 (pc 0x00208b30)
        >>> Write: addr= 0x00000000200ffff8 size=4 data=0x00000000 (pc 0x00208b32)
        >>> Read: addr= 0x00000000200fec4b size=4 data=0x00000000 (pc 0x00208b34)
        >>> Write: addr= 0x00000000200ffffc size=4 data=0x00000000 (pc 0x00208b36)
        >>> Read: addr= 0x00000000200fec4f size=4 data=0x00000000 (pc 0x00208b38)
        >>> Write: addr= 0x0000000020100000 size=4 data=0x00000000 (pc 0x00208b3a)
        >>> [ 0x00208b3a ] INVALID Write: addr= 0x0000000020100000 size=4 data=0x0000000000000000
Execution failed with error code: 7 -> Invalid memory write (UC_ERR_WRITE_UNMAPPED)

==== UC Reg state ====
r0: 0x200fffe8
r1: 0x200fec37
r2: 0xfff019fa
r3: 0x00000000
r4: 0x20001a23
r5: 0x20000675
r6: 0x20001a26
r7: 0x20001c58
r8: 0x000001e1
r9: 0x20000e58
r10: 0x00000000
r11: 0x000000e1
r12: 0x20001a26
lr: 0x00207d39
pc: 0x00208b20
xpsr: 0xa1000000
sp: 0x20002b78
other_sp: 0x00000000
```

We see that a write to address `0x0000000020100000` is attempted from `0x00208b3a`. When inspecting the firmware code as well as the memory region configuration, we find that this corresponds to a write past the data section from within `memcpy`.

From the `lr` (link register), we can find the origin of the `memcpy` call: `lr=0x207d39`. This corresponds to the following pseudocode within the `store_fragment` function:

```
        datalen = packetbuf_datalen(v7);
        memcpy(v4 + 3, v9, datalen - (unsigned __int8)packetbuf_hdr_len);
        // ############ Return Address ############
        return (unsigned __int8)v4[2];
```

As we can see, the `datalen` variable is subtracted from without a minimum size check, after which the result is used in a call to `memcpy`. Upon inspecting further parts of the code, we can verify that the minimum size has not previously been checked sufficiently, either. This leads to an integer underflow, which results in a large out-of-bounds write.
