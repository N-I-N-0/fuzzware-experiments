# Analyzing the Crash
The crash occurs after a context switch `z_arm_pendsv` at `pc=0x00402bde` during large `memmove` in the data section. The large `memmove` write is caused by a fragment sorting issue which leads to an integer underflow (see [bug details](../../../bug-details/CVE-2021-3330_Zephyr_802154_fragment_reassembly_sorting.md) for more information).

> **Note**
> To replay the inputs in this directory, you may need to use the initial version of `fuzzware-emulator` and rebuild fuzzware. For instructions, see [here](https://github.com/fuzzware-fuzzer/fuzzware-experiments/tree/main/04-crash-analysis).

The address in the firmware sample where the header removal is performed in a loop is `0x403C5C`.

Looking inside the debug log for this address, we find the following for the last basic block visit of this address:
```
Basic Block: addr= 0x0000000000403c5c (lr=0x403c7f)
        >>> Read: addr= 0x0000000020107d38 size=4 data=0x2010a677 (pc 0x00403c5c)
        >>> Read: addr= 0x0000000020107d3c size=2 data=0x00000004 (pc 0x00403c5e)
        >>> Read: addr= 0x000000002010a677 size=1 data=0x00000080 (pc 0x00403c60)
Basic Block: addr= 0x000000000040cdbc (lr=0x403c7f)
        >>> Write: addr= 0x20104fa8[SP:+0008] size=4 data=0x201023b0 (pc 0x0040cdc0)
        >>> Write: addr= 0x20104fac[SP:+0004] size=4 data=0x00403c7f (pc 0x0040cdc0)
Basic Block: addr= 0x000000000040cdda (lr=0x403c7f)
        >>> Read: addr= 0x000000002010a67a size=1 data=0x000000ff (pc 0x0040cddc)
        >>> Write: addr= 0x000000002010a675 size=1 data=0x000000ff (pc 0x0040cde0)
Basic Block: addr= 0x000000000040cddc (lr=0x403c7f)
        >>> Read: addr= 0x000000002010a679 size=1 data=0x000000df (pc 0x0040cddc)
        >>> Write: addr= 0x000000002010a674 size=1 data=0x000000df (pc 0x0040cde0)
Basic Block: addr= 0x000000000040cddc (lr=0x403c7f)
        >>> Read: addr= 0x000000002010a678 size=1 data=0x00000080 (pc 0x0040cddc)
        >>> Write: addr= 0x000000002010a673 size=1 data=0x00000080 (pc 0x0040cde0)
Basic Block: addr= 0x000000000040cddc (lr=0x403c7f)
        >>> Read: addr= 0x000000002010a677 size=1 data=0x00000080 (pc 0x0040cddc)
        >>> Write: addr= 0x000000002010a672 size=1 data=0x00000080 (pc 0x0040cde0)
Basic Block: addr= 0x000000000040cddc (lr=0x403c7f)
        >>> Read: addr= 0x000000002010a676 size=1 data=0x000000ff (pc 0x0040cddc)
        >>> Write: addr= 0x000000002010a671 size=1 data=0x000000ff (pc 0x0040cde0)
...
```

As we can see, repeated writes to memory are performed by the `memmove` call which follows the header removal. This large size is a result of the integer underflow which is caused by the sorting issue.