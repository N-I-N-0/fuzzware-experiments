# Analyzing the Crash
The crash occurs in ieee802154_recv at pc=0x0040d0f6, while trying to perform sys_mem_swap on a NULL pointer.

> **Note**
> To replay the inputs in this directory, you may need to use the initial version of `fuzzware-emulator` and rebuild fuzzware. For instructions, see [here](https://github.com/fuzzware-fuzzer/fuzzware-experiments/tree/main/04-crash-analysis).

## Interactive Bug Triaging with known Bug
To interactively see this, set a breakpoint in sys_mem_swap and observe the NULL pointer argument in `r0` to `sys_mem_swap`:

```
./run.sh -b sys_mem_swap
```

```
ipdb> uc.regs
Unicorn Registers:
----------------
r0: 0x00000002
r1: 0x00000003
r2: 0x00000009
r3: 0x00000008
r4: 0x201073c4
r5: 0x20101cc8
r6: 0x00000000
r7: 0x00000003
r8: 0x00000000
r9: 0x00000000
r10: 0x00000000
r11: 0x00000000
r12: 0x00000000
sp: 0x20105ac0
lr: 0x0040d1df
pc: 0x0040d0f6
fpscr: 0x00000000
basepri: 0x00000000
primask: 0x00000000
control: 0x00000002
```

## Trace-based Bug Triaging without known Bug
To analyze the crash without knowing the bug a-priory, we can also follow the memory write log to find the initial corruption. We first pipe the full log into a file:

```
./run.sh > log.txt
```

Inspecting the trace, we first see the crash cause:

```
...
Calling function: sys_mem_swap.constprop.0
...

Basic Block: addr= 0x000000000040d0f6 (lr=0x40d1df)
        >>> Write: addr= 0x20105018[SP:+0008] size=4 data=0x201073c4 (pc 0x0040d0f6)
        >>> Write: addr= 0x2010501c[SP:+0004] size=4 data=0x0040d1df (pc 0x0040d0f6)
        >>> [ 0x0040d100 ] INVALID READ: addr= 0x0000000000000002 size=1 data=0x0000000000000000
Execution failed with error code: 6 -> Invalid memory read (UC_ERR_READ_UNMAPPED)

...
r3: 0x00000008
...
lr: 0x0040d1df
pc: 0x0040d0f6
...
```

According to the crash information, the pointer de-reference which causes the crash occurs at `0x0040d100` on the following instruction: `LDRB.W  R1, [R3,#1]!`, with a value of `0x8` in `r3`.

This means that we are de-referencing the pointer residing in `r3`. We can trace the pointer assignment back to `SUBS    R3, R0, #1` at `0x0040D0F8`, which means that we are de-referencing the `buf` argument to `sys_mem_swap`. This seems to be a corrupted pointer argument to `sys_mem_swap`.

To trace back the reason for this close-to NULL pointer assignment, we can see from `lr=0x0040d1df` that the call to the current function `sys_mem_swap` originates from a static function within `ieee802154_recv`. Looking at the code around the calling location, we find the assignment of the `R0` at firmware code address `0x40D1CE` from a memory read: `LDR     R0, [R4,#0x28]`, which boils down to de-referencing a member of a packet object.

Looking back at the log output, we find the memory read at `0x40D1CE`:
```
Basic Block: addr= 0x000000000040d1ce (lr=0x40d1cf)
        >>> Read: addr= 0x00000000201073ec size=4 data=0x00000002 (pc 0x0040d1ce)
```

This member was read from `0x201073ec`. Looking further back in the trace, we find the following write:

```
Basic Block: addr= 0x000000000040d17c (lr=0x2010a670)
        >>> Read: addr= 0x2010502c[SP:-000c] size=4 data=0x00000000 (pc 0x0040d17c)
        >>> Write: addr= 0x00000000201073f0 size=1 data=0x00000008 (pc 0x0040d188)
        >>> Write: addr= 0x00000000201073ec size=4 data=0x00000002 (pc 0x0040d18c)
```

In pseudocode / source code, this corresponds to:
```
pkt->lladdr_src.addr = (uint8_t *)src_addr;
```

With corresponding assembly:
```
0040D186                 ADDPL   R3, #2
0040D188                 STRB.W  R0, [pkt,#0x2C]
0040D18C                 STR     R3, [pkt,#0x28]
```

This means `pkt->lladdr_src.addr` gets assigned a NULL pointer which is incremented by 2 just before the assignment, which bypasses a NULL pointer check.

Tracking this issue further back leads to the insights also contained in the bug report.